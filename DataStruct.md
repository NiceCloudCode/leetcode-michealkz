## 链表 LinkedList

- 之前网上说的LinkedList的添加和删除的复杂度为O(1) ，但是这种说法只是针对添加或者删除的那一刻的复杂度，即移动指针时候的复杂度是O(1) ，但是真正的运行过程中的时候，添加的话首先是需要找到索引前面的那个元素，那么寻找元素的过程相当于链表的Get的复杂度，也就是O(n)，那么总体来讲是O(n)的。
- 均摊复杂度：动态数组每次添加为O（1），但是最后一次添加的时候涉及到扩容操作，为O(n)，那么将最后一次的复杂度，均摊到前面的多次，
- 什么情况使用均摊复杂度？---> 在经过连续多次复杂度比较低的情况之后，出现个别复杂度较高的情况，此时使用均摊复杂度比较合理。
- 复杂度震荡：先添加元素，等到添加最后一个元素时候扩容，然后删除该元素又缩容量，一直重复此操作的话，复杂度从原来的O(1) 变为O(n) ，从1,1,1,1,1 的复杂度到n,n,n,n 的复杂度，此时出现的情况为复杂度震荡，复杂度震荡是由于 扩容倍数和缩容的时机选择的不正确导致的，只要满足扩容时候的条件乘以缩容时候的条件不为 1 即可避免复杂度震荡。例如扩容为原来的2倍，缩容为原来的1/2 ，此时会产生复杂度震荡。
- 双向链表清空的时候，出现双向引用的情况，即：LinkedList的pre = null，LinkedList的next=null,此时之前创建的双向链表没有被引用，但是在java中也会被gc掉，如果指向的对象不是gc root的对象，就会被gc掉，gc root：1.被栈指针（局部变量）指向的对象，new出来的对象 2.xxx还有其他情况，涉及到JVM相关的内容。
- 看到20了